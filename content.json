{"meta":{"title":"CupOfChino的小破站","subtitle":"","description":"主要用于记录个人的一些心得同时放一些个人的喜好，破站目前仍在不断改进中","author":"CupOfChino","url":"http://cupofchino.github.io","root":"/"},"pages":[{"title":"404","date":"2023-05-27T05:57:51.000Z","updated":"2023-06-02T13:17:23.484Z","comments":true,"path":"404/index.html","permalink":"http://cupofchino.github.io/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-05-27T05:59:41.000Z","updated":"2023-06-02T13:10:50.284Z","comments":true,"path":"categories/index.html","permalink":"http://cupofchino.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-06-10T02:06:14.427Z","updated":"2023-06-09T07:45:19.383Z","comments":true,"path":"categories/index-1.html","permalink":"http://cupofchino.github.io/categories/index-1.html","excerpt":"","text":""},{"title":"about","date":"2023-05-27T05:59:55.000Z","updated":"2023-06-02T13:13:05.967Z","comments":true,"path":"about/index.html","permalink":"http://cupofchino.github.io/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2023-06-02T13:13:48.000Z","updated":"2023-06-02T13:14:27.609Z","comments":true,"path":"contact/index.html","permalink":"http://cupofchino.github.io/contact/index.html","excerpt":"","text":""},{"title":"search","date":"2023-05-27T05:56:09.000Z","updated":"2023-05-27T05:56:09.475Z","comments":true,"path":"search/index.html","permalink":"http://cupofchino.github.io/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-06-02T13:11:39.000Z","updated":"2023-06-02T13:12:20.944Z","comments":true,"path":"tags/index.html","permalink":"http://cupofchino.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"20231014 study","slug":"20231014study","date":"2023-10-14T11:45:26.000Z","updated":"2023-10-14T12:34:17.847Z","comments":true,"path":"2023/10/14/20231014study/","link":"","permalink":"http://cupofchino.github.io/2023/10/14/20231014study/","excerpt":"","text":"递归算法，我个人的感觉类似于数学当中找数学表达式以及找规律，找到了解决问题的表达式和规律，那么递归也就很好解决。通过下面这个c语言的程序，体会会更明显#include&lt;stdio.h&gt;void calculate1(int a){ int i,remember; int num[10]; for(i=0;i&lt;10;i++) { num[i]=a%10; remember=i; if(a&lt;10) { break; } a=a/10; } for(int j=0;j&lt;=remember;j++) { printf(“%d “,num[remember-j]); }} void calculate2(int a){ if(a&gt;=10) { calculate2(a/10); } printf(“%d “,a%10);} int main(){ int a=20456; calculate1(a); printf(“\\n”); calculate2(a); return 0;} 上面的代码的功能是将一个整数的各个位的数字分别输出其中calculate1这个函数便是最基础的循环操作可以看出来，在for循环中，我们首先是从i=0开始，然后逐渐累加最后得出答案。在calculate2这个函数中，便是使用了递归这个算法，非常简洁但也难懂。calculate2（a/10）这一段话的意思便是将a除以10.然后将剩下的部分继续代入其中计算，以此来达到目的递归结束条件便是当a小于10，此时只会输出a，不会再递归 ###################################################################### 第二个例子:阶乘#include&lt;stdio.h&gt;int factorial(int a) //阶乘{ if(a&lt;=1) { return 1; } return a=a*factorial(a-1);} int main(){ int a=5; int b; b=factorial(a); printf(“%d”,b); return 0;} ############################################################################ 第三个例子:斐波那契数列 #include&lt;stdio.h&gt;int Fibonacci(int a){ if(a&lt;=2) { return 1; } return Fibonacci(a-1)+Fibonacci(a-2);} int main(){ int a=6; int b; b=Fibonacci(a); printf(“%d”,b); return 0;} /*当你写 return Fibonacci(a) = Fibonacci(a-1) + Fibonacci(a-2); 时，编译器会将这个表达式解析为： 调用 Fibonacci(a) 函数的结果；将之前调用 Fibonacci(a) 函数返回的值赋值给 Fibonacci(a-1) + Fibonacci(a-2)。显然这个表达式不符合语法规则，因为把一个值赋给一个表达式是没有任何意义的。所以编译器会报错。 换成正确的表达式 return Fibonacci(a-1) + Fibonacci(a-2);，就表示该函数的返回值是调用 Fibonacci(a-1) 和 Fibonacci(a-2) 的结果之和。而递归的终止条件是 a==1 或 a==2，这个时候直接返回1即可。 意思是正确的，只是在表达上出了一些问题。应该使用递归函数来计算斐波那契数列的值，而不应该把递归函数的结果赋值给另一个表达式。*/ #############################################################第四个例子:计算数组中数字的和 #include&lt;stdio.h&gt;int calculate(int *a,int size){ if(size==0) { return 0; } return a[0]+calculate(a+1,size-1);} int main(){ int a[5]={1,2,3,4,5}; int size=sizeof(a)/sizeof(a[0]); int end=calculate(a,size); printf(“%d”,end); return 0;} /*在 calculate函数中，我们传入一个指向数组的指针 a和数组的大小 size。如果 size 等于 0，则返回和的初始值 0。否则，将数组的第一个元素与后续部分（通过指针 a+1 和 size-1 缩小了数组的范围）的和相加，然后递归调用该函数计算剩余部分的和。为什么能这样捏？这是因为在c中这个指向数组的指针实际上指向的是数组起始位置的地址，因而当a+1之后，指针就会移动到数组的下一位了 ########################################################################################还有一个非常有用的地方，如果不用循环想找到数组的大小很麻烦###但是，在这代码中，我们使用sizeof 来计算整数数组a中元素的个数###具体来说，sizeof(array) 返回整个数组的字节数，而 sizeof(a[0]) 返回数组元素的字节数###因此，通过将整个数组的字节数除以元素字节数，可以得到数组的元素个数###这个技巧可以很方便地避免硬编码数组大小，特别是当数组的大小在程序运行时可能发生变化##################################################################################### 第五个例子:判断字符串左右两边字母是否完全相同 #include&lt;stdio.h&gt; void compareA(char a[],int size,int start) //老函数{ if(size==start||size==start-1) { if(a[size]==a[start]) { printf(“yes\\n”); return; //防止死循环 } else { printf(“no\\n”); return; } } if(a[size]!=a[start]) { printf(“no\\n”); return; } compareA(a,size-1,start+1);} void compareB(char a[],int size,int start) //新函数{ if(size&lt;=start) { printf(“yes\\n”); return; } if(a[size]!=a[start]) { printf(“no\\n”); return; } compareB(a,size-1,start+1);} /*判断条件是 start &gt;= size，而不是你之前写的 size==start||size==start-1，这是因为：当字符串长度为奇数时，比如 “madam”，中心字符是对称的，所以在比较到中心字符时，不需要进行实际比较。因此，在长度为奇数的回文字符串中，最后一次比较实际上是比较了 2 个相同字符，即开始位置和结束位置重合时的字符，也就是说，start 位置和 size 位置指向同一个字符。因此，当 start 大于等于 size 时，我们可以认为整个字符串已经完成了比较，不需要继续递归下去。同时返回 “yes” 表示字符串是回文的。当字符串长度为偶数时，比如 “apple”，不存在中心字符，所有字符都必须进行比较。因此，在长度为偶数的回文字符串中，最后一次比较实际上是比较了 2 个不同的字符，即开始位置和结束位置重合时的字符。因此，如果我们按照你之前写的方法，判断条件为 size==start||size==start-1，那么当递归到最后一步时，会输出 “no”，而不是 “yes”。因此，为了处理长度为偶数的回文字符串，我们需要使用 start &gt;= size 来判断是否完成比较。*/ void calculate(char a[],int size){ printf(“老函数的结果为:\\n”); compareA(a,size-1,0); printf(“新函数的结果为:\\n”); compareB(a,size-1,0);} int main(){ char ch1[5]={‘m’,’a’,’d’,’a’,’m’}; char ch2[5]={‘a’,’b’,’p’,’e’,’a’}; int size1=sizeof(ch1)/sizeof(ch1[0]); int size2=sizeof(ch2)/sizeof(ch2[0]); calculate(ch1,size1); calculate(ch2,size2); return 0;} ####################################################################################### 第六个例子：汉诺塔问题 #include&lt;stdio.h&gt;void hanoi(int n,char a,char b,char c) //a为移动起始地，b为移动中转地，c为目的地{ if(n&gt;1) { hanoi(n-1,a,c,b); printf(“%c-&gt;%c\\n”,a,c); hanoi(n-1,b,a,c); } else { printf(“%c-&gt;%c\\n”,a,c); }} int main(){ char a=’A’; char b=’B’; char c=’C’; printf(“third\\n”); hanoi(3,a,b,c); return 0;} /汉诺塔问题，详情可见http://t.csdnimg.cn/2dBAx 十分详细/不过本人在做汉诺塔时碰到了一个问题，如果我分别令n为1，2，3，4，5，并在n变换为不同值的时候在终端输出提示，按照我上面代码的逻辑应该没有任何问题。但在实际中输出结果先是出现了一大段的空白，随后直接输出了结果，但这结果中却并未输出提示语句，然而我提示语句是放在main函数中。询问gpt老师之后得到答复为: printf 函数的输出结果和程序缓存区域之间的关系。具体来说， 很多编译器都会有输出缓存的概念，如果没有手动刷新缓存区， 这些输出内容就不会被及时地显示在终端中。 这就解释了你所说的“大量的空白”问题。 针对这个问题，你可以手动刷新缓存区使用 fflush(stdout) 函数强制将缓冲区中的内容输出到终端上。在你的代码中，在 printf 输出语句之后调用 fflush(stdout) 语句，就能及时显示输出结果了。 然而按照gpt老师说法改却没有一点用，这令我非常疑惑 ##########################################################################","categories":[],"tags":[]},{"title":"20231010","slug":"20231010","date":"2023-10-10T13:12:57.000Z","updated":"2023-10-10T13:39:14.272Z","comments":true,"path":"2023/10/10/20231010/","link":"","permalink":"http://cupofchino.github.io/2023/10/10/20231010/","excerpt":"","text":"今日份学习成果：java:java的输入首先要有类似于和c语言一样的头文件:import java.until.Scanner;像带import这样的语句放置位置需要在文件顶端 接下来便是:Scanner scanner=new Scanner(System.in);int num=scanner.nextInt(); //输入整数double floatNum=scanner.nexDouble(); //输入浮点数char ch=scanner.next().charAt(0); //输入单个字符（此处的0指的是输出第0个位置的字符，如果想输出一个字符串中某一位置的字符，那么将0换成对应位置的值即可）String input=scanner.next(); //输入字符串输入数组:int[] nums=new int[length]; //定义数组,此处的length可以随便赋值for(int i=0;i&lt;length;i++){ nums[i]=scanner.nextInt(); //输入数组，此处也可以仿照上面进行局部修改从而输入不同类型的数组}输出数组的方法：int[] nums={1,2,3,4,5};System.out.println(Arrays.to String(nums)); //输出字符串只需将int改为string即可 关于输出的方法:int num=2;System.out.println(“a” +num); //结果为:a2并会换行System.out.print(“a” +num); //结果为:a2不换行System.out.print(“\\n”); //结果换行System.out.printf(“a%d\\n”,num); //结果为:a2换行 c语言:结构体的定义:#include&lt;sdtio.h&gt;struct a{ char name[10]; int x;}; //下面结构体数组的定义的方法之一 int main(){ struct a A[2];} …数组比较的方法:eg: char a[3];char b[3];strcmp(a,b)==0; //相同则为0//头文件为string.h 今天写的内容:java： package study;import java.util.Arrays;import java.util.Scanner; public class study { public static void main(String[] args) { Scanner scanner=new Scanner(System.in); System.out.println(\"请输入一个整数:\"); int num=scanner.nextInt(); System.out.println(\"输入的整数为\" +num); System.out.print(\"请输入一个浮点数\\n\"); double floatNum=scanner.nextDouble(); System.out.print(\"你输入的浮点数为:\" +floatNum); System.out.print(\"\\n\"); System.out.printf(\"请输入你想输入数组的大小：%n\"); int length=scanner.nextInt(); int[] arr=new int[length]; System.out.printf(\"请输入数组的数:%n\"); for(int i=0;i&lt;length;i++) { arr[i]=scanner.nextInt(); } System.out.print(\"数组内的数为:\\n\" ); System.out.println(Arrays.toString(arr)); System.out.println(\"请输入一个字符:\"); char ch=scanner.next().charAt(0); System.out.println(\"输入的字符为: \" +ch); System.out.println(\"请输入一个大小在4个字母以内的字符串:\"); String input=scanner.next(); char ch1=input.charAt(2); System.out.println(\"你输入的字符串为: \"+input); System.out.println(\"其中字符串的第三位是: \"+ch1); } } c: #include&lt;stdio.h&gt;#include &lt;string.h&gt;struct system{ char name[20]; //型号 char size[20]; //尺寸 int price; //价格 char disposition[20]; //配置}; int main(){ int a,remember1=0,remember2=0,number1=0,number2=0; char compare[20]={“xiaomi”}; printf(“请输入你带来多少组数据:\\n”); scanf(“%d”,&amp;a); struct system Systems[a]; printf(“请输入数据:\\n”); printf(“型号(字符型数组) 尺寸(字符型数组) 价格(整型) 配置(字符型数组)\\n”); for(int i=0;i&lt;a;i++) { printf(“第%d次输入:\\n”,i+1); scanf(“%s %s %d %s”,&amp;Systems[i].name,&amp;Systems[i].size,&amp;Systems[i].price,&amp;Systems[i].disposition); if(strcmp(Systems[i].name, compare)==0) { remember1=remember1+Systems-&gt;price; number1=number1+1; } else { remember2=remember2+Systems-&gt;price; number2=number2+1; } } printf(“最终，你所存入的数据如下：\\n”); for(int j=0;j&lt;a;j++) { printf(“这是仓库中存入第%d个手机\\n型号为:%s\\n尺寸为:%s\\n价格为:%d\\n配置为:%s\\n”,j+1,Systems[j].name,Systems[j].size,Systems[j].price,Systems[j].disposition); } printf(“仓库中xiaomi型号共有%d台，总价为%d元\\n”,number1,remember1); printf(“仓库中huawei型号共有%d台，总价为%d元\\n”,number2,remember2); return 0;}","categories":[],"tags":[]},{"title":"水一下^-^","slug":"new","date":"2023-06-02T15:12:06.000Z","updated":"2023-06-02T15:15:27.202Z","comments":true,"path":"2023/06/02/new/","link":"","permalink":"http://cupofchino.github.io/2023/06/02/new/","excerpt":"","text":"啊哈，今天对我的小破站进行了比较大的更改，加了不少图片以及一些功能后续评论也将加入其中^-^","categories":[],"tags":[]},{"title":"一些个人向的分享（还在不断补充）","slug":"my share(to me)","date":"2023-05-28T12:46:59.000Z","updated":"2023-05-28T12:47:50.914Z","comments":true,"path":"2023/05/28/my-share-to-me/","link":"","permalink":"http://cupofchino.github.io/2023/05/28/my-share-to-me/","excerpt":"","text":"闲来无事挂一些我自己收藏的一些东西主要是担心放的太杂自己找不到了^-^以下均在天翼云盘（百度网盘去死） 智乃酱萌图：https://cloud.189.cn/t/vEbEJfzQzIby 访问码：7x8b亚托莉Q版：https://cloud.189.cn/t/NNbAraze2mqq 访问码：1gue 点兔中我比较喜欢的音乐：https://cloud.189.cn/t/N3YzuuJnYFVj 访问码：gp8n 其他等待我后续补充^-^","categories":[],"tags":[]},{"title":"二次测试","slug":"twice-test","date":"2023-05-27T07:53:36.000Z","updated":"2023-05-27T08:54:19.734Z","comments":true,"path":"2023/05/27/twice-test/","link":"","permalink":"http://cupofchino.github.io/2023/05/27/twice-test/","excerpt":"","text":"测试为中文标题和能否分类 测试失败&gt;_&lt;中文标题暂时用不了，不知道怎么改分类应该没问题吧(maybe)不想找了，功能将在6月期末考完后逐渐完善简单来说就是先摆一会打游戏去了 nmmd，英语文档不能用空格是吧嘶，分类功能好像也有问题用不了，淦 破案了，分类功能导致上传出问题，不是不能用中文标题唉，比想象的难多了 之前的那个主题在手机上会出现严重的错误，于是换了一个不知道这个怎么样不够好像功能丢失了一些，还得接着研究","categories":[],"tags":[]}],"categories":[],"tags":[]}